(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[96915],{59372:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/en/docs/guides/event-loop-timers-and-nexttick",function(){return s(84144)}])},84144:function(e,n,s){"use strict";s.r(n),s.d(n,{__N_SSG:function(){return r}});var t=s(26042),i=s(69396),l=s(85893),o=s(48863),a=s(11151);function c(e){var n=Object.assign({h1:"h1",code:"code",h2:"h2",p:"p",strong:"strong",a:"a",pre:"pre",blockquote:"blockquote",em:"em",ul:"ul",li:"li",h3:"h3",ol:"ol"},(0,a.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{children:["The Node.js Event Loop, Timers, and ",(0,l.jsx)(n.code,{children:"process.nextTick()"})]}),"\n",(0,l.jsx)(n.h2,{id:"what-is-the-event-loop",children:"What is the Event Loop?"}),"\n",(0,l.jsx)(n.p,{children:"The event loop is what allows Node.js to perform non-blocking I/O\noperations — despite the fact that JavaScript is single-threaded — by\noffloading operations to the system kernel whenever possible."}),"\n",(0,l.jsxs)(n.p,{children:["Since most modern kernels are multi-threaded, they can handle multiple\noperations executing in the background. When one of these operations\ncompletes, the kernel tells Node.js so that the appropriate callback\nmay be added to the ",(0,l.jsx)(n.strong,{children:"poll"})," queue to eventually be executed. We'll explain\nthis in further detail later in this topic."]}),"\n",(0,l.jsx)(n.h2,{id:"event-loop-explained",children:"Event Loop Explained"}),"\n",(0,l.jsxs)(n.p,{children:["When Node.js starts, it initializes the event loop, processes the\nprovided input script (or drops into the ",(0,l.jsx)(n.a,{href:"https://nodejs.org/api/repl.html#repl_repl",children:"REPL"}),", which is not covered in\nthis document) which may make async API calls, schedule timers, or call\n",(0,l.jsx)(n.code,{children:"process.nextTick()"}),", then begins processing the event loop."]}),"\n",(0,l.jsx)(n.p,{children:"The following diagram shows a simplified overview of the event loop's\norder of operations."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:'Each box will be referred to as a "phase" of the event loop.'}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Each phase has a FIFO queue of callbacks to execute. While each phase is\nspecial in its own way, generally, when the event loop enters a given\nphase, it will perform any operations specific to that phase, then\nexecute callbacks in that phase's queue until the queue has been\nexhausted or the maximum number of callbacks has executed. When the\nqueue has been exhausted or the callback limit is reached, the event\nloop will move to the next phase, and so on."}),"\n",(0,l.jsxs)(n.p,{children:["Since any of these operations may schedule ",(0,l.jsx)(n.em,{children:"more"})," operations and new\nevents processed in the ",(0,l.jsx)(n.strong,{children:"poll"})," phase are queued by the kernel, poll\nevents can be queued while polling events are being processed. As a\nresult, long running callbacks can allow the poll phase to run much\nlonger than a timer's threshold. See the ",(0,l.jsx)(n.a,{href:"#timers",children:(0,l.jsx)(n.strong,{children:"timers"})})," and\n",(0,l.jsx)(n.a,{href:"#poll",children:(0,l.jsx)(n.strong,{children:"poll"})})," sections for more details."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"There is a slight discrepancy between the Windows and the\nUnix/Linux implementation, but that's not important for this\ndemonstration. The most important parts are here. There are actually\nseven or eight steps, but the ones we care about — ones that Node.js\nactually uses - are those above."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"phases-overview",children:"Phases Overview"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"timers"}),": this phase executes callbacks scheduled by ",(0,l.jsx)(n.code,{children:"setTimeout()"}),"\nand ",(0,l.jsx)(n.code,{children:"setInterval()"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"pending callbacks"}),": executes I/O callbacks deferred to the next loop\niteration."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"idle, prepare"}),": only used internally."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"poll"}),": retrieve new I/O events; execute I/O related callbacks (almost\nall with the exception of close callbacks, the ones scheduled by timers,\nand ",(0,l.jsx)(n.code,{children:"setImmediate()"}),"); node will block here when appropriate."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"check"}),": ",(0,l.jsx)(n.code,{children:"setImmediate()"})," callbacks are invoked here."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"close callbacks"}),": some close callbacks, e.g. ",(0,l.jsx)(n.code,{children:"socket.on('close', ...)"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Between each run of the event loop, Node.js checks if it is waiting for\nany asynchronous I/O or timers and shuts down cleanly if there are not\nany."}),"\n",(0,l.jsx)(n.h2,{id:"phases-in-detail",children:"Phases in Detail"}),"\n",(0,l.jsx)(n.h3,{id:"timers",children:"timers"}),"\n",(0,l.jsxs)(n.p,{children:["A timer specifies the ",(0,l.jsx)(n.strong,{children:"threshold"})," ",(0,l.jsx)(n.em,{children:"after which"})," a provided callback\n",(0,l.jsx)(n.em,{children:"may be executed"})," rather than the ",(0,l.jsx)(n.strong,{children:"exact"})," time a person ",(0,l.jsx)(n.em,{children:"wants it to\nbe executed"}),". Timers callbacks will run as early as they can be\nscheduled after the specified amount of time has passed; however,\nOperating System scheduling or the running of other callbacks may delay\nthem."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Technically, the ",(0,l.jsxs)(n.a,{href:"#poll",children:[(0,l.jsx)(n.strong,{children:"poll"})," phase"]})," controls when timers are executed."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"For example, say you schedule a timeout to execute after a 100 ms\nthreshold, then your script starts asynchronously reading a file which\ntakes 95 ms:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const fs = require('fs');\n\nfunction someAsyncOperation(callback) {\n  // Assume this takes 95ms to complete\n  fs.readFile('/path/to/file', callback);\n}\n\nconst timeoutScheduled = Date.now();\n\nsetTimeout(() => {\n  const delay = Date.now() - timeoutScheduled;\n\n  console.log(`${delay}ms have passed since I was scheduled`);\n}, 100);\n\n// do someAsyncOperation which takes 95 ms to complete\nsomeAsyncOperation(() => {\n  const startCallback = Date.now();\n\n  // do something that will take 10ms...\n  while (Date.now() - startCallback < 10) {\n    // do nothing\n  }\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["When the event loop enters the ",(0,l.jsx)(n.strong,{children:"poll"})," phase, it has an empty queue\n(",(0,l.jsx)(n.code,{children:"fs.readFile()"})," has not completed), so it will wait for the number of ms\nremaining until the soonest timer's threshold is reached. While it is\nwaiting 95 ms pass, ",(0,l.jsx)(n.code,{children:"fs.readFile()"})," finishes reading the file and its\ncallback which takes 10 ms to complete is added to the ",(0,l.jsx)(n.strong,{children:"poll"})," queue and\nexecuted. When the callback finishes, there are no more callbacks in the\nqueue, so the event loop will see that the threshold of the soonest\ntimer has been reached then wrap back to the ",(0,l.jsx)(n.strong,{children:"timers"})," phase to execute\nthe timer's callback. In this example, you will see that the total delay\nbetween the timer being scheduled and its callback being executed will\nbe 105ms."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["To prevent the ",(0,l.jsx)(n.strong,{children:"poll"})," phase from starving the event loop, ",(0,l.jsx)(n.a,{href:"https://libuv.org/",children:"libuv"}),"\n(the C library that implements the Node.js\nevent loop and all of the asynchronous behaviors of the platform)\nalso has a hard maximum (system dependent) before it stops polling for\nmore events."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"pending-callbacks",children:"pending callbacks"}),"\n",(0,l.jsxs)(n.p,{children:["This phase executes callbacks for some system operations such as types\nof TCP errors. For example if a TCP socket receives ",(0,l.jsx)(n.code,{children:"ECONNREFUSED"})," when\nattempting to connect, some *nix systems want to wait to report the\nerror. This will be queued to execute in the ",(0,l.jsx)(n.strong,{children:"pending callbacks"})," phase."]}),"\n",(0,l.jsx)(n.h3,{id:"poll",children:"poll"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.strong,{children:"poll"})," phase has two main functions:"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Calculating how long it should block and poll for I/O, then"}),"\n",(0,l.jsxs)(n.li,{children:["Processing events in the ",(0,l.jsx)(n.strong,{children:"poll"})," queue."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["When the event loop enters the ",(0,l.jsx)(n.strong,{children:"poll"})," phase ",(0,l.jsx)(n.em,{children:"and there are no timers\nscheduled"}),", one of two things will happen:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.em,{children:["If the ",(0,l.jsx)(n.strong,{children:"poll"})," queue ",(0,l.jsx)(n.strong,{children:"is not empty"})]}),", the event loop will iterate\nthrough its queue of callbacks executing them synchronously until\neither the queue has been exhausted, or the system-dependent hard limit\nis reached."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.em,{children:["If the ",(0,l.jsx)(n.strong,{children:"poll"})," queue ",(0,l.jsx)(n.strong,{children:"is empty"})]}),", one of two more things will\nhappen:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["If scripts have been scheduled by ",(0,l.jsx)(n.code,{children:"setImmediate()"}),", the event loop\nwill end the ",(0,l.jsx)(n.strong,{children:"poll"})," phase and continue to the ",(0,l.jsx)(n.strong,{children:"check"})," phase to\nexecute those scheduled scripts."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["If scripts ",(0,l.jsx)(n.strong,{children:"have not"})," been scheduled by ",(0,l.jsx)(n.code,{children:"setImmediate()"}),", the\nevent loop will wait for callbacks to be added to the queue, then\nexecute them immediately."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Once the ",(0,l.jsx)(n.strong,{children:"poll"})," queue is empty the event loop will check for timers\n",(0,l.jsx)(n.em,{children:"whose time thresholds have been reached"}),". If one or more timers are\nready, the event loop will wrap back to the ",(0,l.jsx)(n.strong,{children:"timers"})," phase to execute\nthose timers' callbacks."]}),"\n",(0,l.jsx)(n.h3,{id:"check",children:"check"}),"\n",(0,l.jsxs)(n.p,{children:["This phase allows a person to execute callbacks immediately after the\n",(0,l.jsx)(n.strong,{children:"poll"})," phase has completed. If the ",(0,l.jsx)(n.strong,{children:"poll"})," phase becomes idle and\nscripts have been queued with ",(0,l.jsx)(n.code,{children:"setImmediate()"}),", the event loop may\ncontinue to the ",(0,l.jsx)(n.strong,{children:"check"})," phase rather than waiting."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"setImmediate()"})," is actually a special timer that runs in a separate\nphase of the event loop. It uses a libuv API that schedules callbacks to\nexecute after the ",(0,l.jsx)(n.strong,{children:"poll"})," phase has completed."]}),"\n",(0,l.jsxs)(n.p,{children:["Generally, as the code is executed, the event loop will eventually hit\nthe ",(0,l.jsx)(n.strong,{children:"poll"})," phase where it will wait for an incoming connection, request,\netc. However, if a callback has been scheduled with ",(0,l.jsx)(n.code,{children:"setImmediate()"}),"\nand the ",(0,l.jsx)(n.strong,{children:"poll"})," phase becomes idle, it will end and continue to the\n",(0,l.jsx)(n.strong,{children:"check"})," phase rather than waiting for ",(0,l.jsx)(n.strong,{children:"poll"})," events."]}),"\n",(0,l.jsx)(n.h3,{id:"close-callbacks",children:"close callbacks"}),"\n",(0,l.jsxs)(n.p,{children:["If a socket or handle is closed abruptly (e.g. ",(0,l.jsx)(n.code,{children:"socket.destroy()"}),"), the\n",(0,l.jsx)(n.code,{children:"'close'"})," event will be emitted in this phase. Otherwise it will be\nemitted via ",(0,l.jsx)(n.code,{children:"process.nextTick()"}),"."]}),"\n",(0,l.jsxs)(n.h2,{id:"setimmediate-vs-settimeout",children:[(0,l.jsx)(n.code,{children:"setImmediate()"})," vs ",(0,l.jsx)(n.code,{children:"setTimeout()"})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"setImmediate()"})," and ",(0,l.jsx)(n.code,{children:"setTimeout()"})," are similar, but behave in different\nways depending on when they are called."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"setImmediate()"})," is designed to execute a script once the\ncurrent ",(0,l.jsx)(n.strong,{children:"poll"})," phase completes."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"setTimeout()"})," schedules a script to be run after a minimum threshold\nin ms has elapsed."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The order in which the timers are executed will vary depending on the\ncontext in which they are called. If both are called from within the\nmain module, then timing will be bound by the performance of the process\n(which can be impacted by other applications running on the machine)."}),"\n",(0,l.jsx)(n.p,{children:"For example, if we run the following script which is not within an I/O\ncycle (i.e. the main module), the order in which the two timers are\nexecuted is non-deterministic, as it is bound by the performance of the\nprocess:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"// timeout_vs_immediate.js\nsetTimeout(() => {\n  console.log('timeout');\n}, 0);\n\nsetImmediate(() => {\n  console.log('immediate');\n});\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"$ node timeout_vs_immediate.js\ntimeout\nimmediate\n\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\n"})}),"\n",(0,l.jsx)(n.p,{children:"However, if you move the two calls within an I/O cycle, the immediate\ncallback is always executed first:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"// timeout_vs_immediate.js\nconst fs = require('fs');\n\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log('timeout');\n  }, 0);\n  setImmediate(() => {\n    console.log('immediate');\n  });\n});\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"$ node timeout_vs_immediate.js\nimmediate\ntimeout\n\n$ node timeout_vs_immediate.js\nimmediate\ntimeout\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The main advantage to using ",(0,l.jsx)(n.code,{children:"setImmediate()"})," over ",(0,l.jsx)(n.code,{children:"setTimeout()"})," is\n",(0,l.jsx)(n.code,{children:"setImmediate()"})," will always be executed before any timers if scheduled\nwithin an I/O cycle, independently of how many timers are present."]}),"\n",(0,l.jsx)(n.h2,{id:"processnexttick",children:(0,l.jsx)(n.code,{children:"process.nextTick()"})}),"\n",(0,l.jsxs)(n.h3,{id:"understanding-processnexttick",children:["Understanding ",(0,l.jsx)(n.code,{children:"process.nextTick()"})]}),"\n",(0,l.jsxs)(n.p,{children:["You may have noticed that ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," was not displayed in the\ndiagram, even though it's a part of the asynchronous API. This is because\n",(0,l.jsx)(n.code,{children:"process.nextTick()"})," is not technically part of the event loop. Instead,\nthe ",(0,l.jsx)(n.code,{children:"nextTickQueue"})," will be processed after the current operation is\ncompleted, regardless of the current phase of the event loop. Here,\nan ",(0,l.jsx)(n.em,{children:"operation"})," is defined as a transition from the\nunderlying C/C++ handler, and handling the JavaScript that needs to be\nexecuted."]}),"\n",(0,l.jsxs)(n.p,{children:["Looking back at our diagram, any time you call ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," in a\ngiven phase, all callbacks passed to ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," will be\nresolved before the event loop continues. This can create some bad\nsituations because ",(0,l.jsxs)(n.strong,{children:['it allows you to "starve" your I/O by making\nrecursive ',(0,l.jsx)(n.code,{children:"process.nextTick()"})," calls"]}),", which prevents the event loop\nfrom reaching the ",(0,l.jsx)(n.strong,{children:"poll"})," phase."]}),"\n",(0,l.jsx)(n.h3,{id:"why-would-that-be-allowed",children:"Why would that be allowed?"}),"\n",(0,l.jsx)(n.p,{children:"Why would something like this be included in Node.js? Part of it is a\ndesign philosophy where an API should always be asynchronous even where\nit doesn't have to be. Take this code snippet for example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"function apiCall(arg, callback) {\n  if (typeof arg !== 'string')\n    return process.nextTick(\n      callback,\n      new TypeError('argument should be string')\n    );\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The snippet does an argument check and if it's not correct, it will pass\nthe error to the callback. The API updated fairly recently to allow\npassing arguments to ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," allowing it to take any\narguments passed after the callback to be propagated as the arguments to\nthe callback so you don't have to nest functions."]}),"\n",(0,l.jsxs)(n.p,{children:["What we're doing is passing an error back to the user but only ",(0,l.jsx)(n.em,{children:"after"}),"\nwe have allowed the rest of the user's code to execute. By using\n",(0,l.jsx)(n.code,{children:"process.nextTick()"})," we guarantee that ",(0,l.jsx)(n.code,{children:"apiCall()"})," always runs its\ncallback ",(0,l.jsx)(n.em,{children:"after"})," the rest of the user's code and ",(0,l.jsx)(n.em,{children:"before"})," the event loop\nis allowed to proceed. To achieve this, the JS call stack is allowed to\nunwind then immediately execute the provided callback which allows a\nperson to make recursive calls to ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," without reaching a\n",(0,l.jsx)(n.code,{children:"RangeError: Maximum call stack size exceeded from v8"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"This philosophy can lead to some potentially problematic situations.\nTake this snippet for example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"let bar;\n\n// this has an asynchronous signature, but calls callback synchronously\nfunction someAsyncApiCall(callback) {\n  callback();\n}\n\n// the callback is called before `someAsyncApiCall` completes.\nsomeAsyncApiCall(() => {\n  // since someAsyncApiCall hasn't completed, bar hasn't been assigned any value\n  console.log('bar', bar); // undefined\n});\n\nbar = 1;\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The user defines ",(0,l.jsx)(n.code,{children:"someAsyncApiCall()"})," to have an asynchronous signature,\nbut it actually operates synchronously. When it is called, the callback\nprovided to ",(0,l.jsx)(n.code,{children:"someAsyncApiCall()"})," is called in the same phase of the\nevent loop because ",(0,l.jsx)(n.code,{children:"someAsyncApiCall()"})," doesn't actually do anything\nasynchronously. As a result, the callback tries to reference ",(0,l.jsx)(n.code,{children:"bar"})," even\nthough it may not have that variable in scope yet, because the script has not\nbeen able to run to completion."]}),"\n",(0,l.jsxs)(n.p,{children:["By placing the callback in a ",(0,l.jsx)(n.code,{children:"process.nextTick()"}),", the script still has the\nability to run to completion, allowing all the variables, functions,\netc., to be initialized prior to the callback being called. It also has\nthe advantage of not allowing the event loop to continue. It may be\nuseful for the user to be alerted to an error before the event loop is\nallowed to continue. Here is the previous example using ",(0,l.jsx)(n.code,{children:"process.nextTick()"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"let bar;\n\nfunction someAsyncApiCall(callback) {\n  process.nextTick(callback);\n}\n\nsomeAsyncApiCall(() => {\n  console.log('bar', bar); // 1\n});\n\nbar = 1;\n"})}),"\n",(0,l.jsx)(n.p,{children:"Here's another real world example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const server = net.createServer(() => {}).listen(8080);\n\nserver.on('listening', () => {});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["When only a port is passed, the port is bound immediately. So, the\n",(0,l.jsx)(n.code,{children:"'listening'"})," callback could be called immediately. The problem is that the\n",(0,l.jsx)(n.code,{children:".on('listening')"})," callback will not have been set by that time."]}),"\n",(0,l.jsxs)(n.p,{children:["To get around this, the ",(0,l.jsx)(n.code,{children:"'listening'"})," event is queued in a ",(0,l.jsx)(n.code,{children:"nextTick()"}),"\nto allow the script to run to completion. This allows the user to set\nany event handlers they want."]}),"\n",(0,l.jsxs)(n.h2,{id:"processnexttick-vs-setimmediate",children:[(0,l.jsx)(n.code,{children:"process.nextTick()"})," vs ",(0,l.jsx)(n.code,{children:"setImmediate()"})]}),"\n",(0,l.jsx)(n.p,{children:"We have two calls that are similar as far as users are concerned, but\ntheir names are confusing."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"process.nextTick()"})," fires immediately on the same phase"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"setImmediate()"})," fires on the following iteration or 'tick' of the\nevent loop"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["In essence, the names should be swapped. ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," fires more\nimmediately than ",(0,l.jsx)(n.code,{children:"setImmediate()"}),", but this is an artifact of the past\nwhich is unlikely to change. Making this switch would break a large\npercentage of the packages on npm. Every day more new modules are being\nadded, which means every day we wait, more potential breakages occur.\nWhile they are confusing, the names themselves won't change."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["We recommend developers use ",(0,l.jsx)(n.code,{children:"setImmediate()"})," in all cases because it's\neasier to reason about."]}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"why-use-processnexttick",children:["Why use ",(0,l.jsx)(n.code,{children:"process.nextTick()"}),"?"]}),"\n",(0,l.jsx)(n.p,{children:"There are two main reasons:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Allow users to handle errors, cleanup any then unneeded resources, or\nperhaps try the request again before the event loop continues."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"At times it's necessary to allow a callback to run after the call\nstack has unwound but before the event loop continues."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"One example is to match the user's expectations. Simple example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const server = net.createServer();\nserver.on('connection', (conn) => {});\n\nserver.listen(8080);\nserver.on('listening', () => {});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Say that ",(0,l.jsx)(n.code,{children:"listen()"})," is run at the beginning of the event loop, but the\nlistening callback is placed in a ",(0,l.jsx)(n.code,{children:"setImmediate()"}),". Unless a\nhostname is passed, binding to the port will happen immediately. For\nthe event loop to proceed, it must hit the ",(0,l.jsx)(n.strong,{children:"poll"})," phase, which means\nthere is a non-zero chance that a connection could have been received\nallowing the connection event to be fired before the listening event."]}),"\n",(0,l.jsxs)(n.p,{children:["Another example is extending an ",(0,l.jsx)(n.code,{children:"EventEmitter"})," and emitting an\nevent from within the constructor:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {\n  constructor() {\n    super();\n    this.emit('event');\n  }\n}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["You can't emit an event from the constructor immediately\nbecause the script will not have processed to the point where the user\nassigns a callback to that event. So, within the constructor itself,\nyou can use ",(0,l.jsx)(n.code,{children:"process.nextTick()"})," to set a callback to emit the event\nafter the constructor has finished, which provides the expected results:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {\n  constructor() {\n    super();\n\n    // use nextTick to emit the event once a handler is assigned\n    process.nextTick(() => {\n      this.emit('event');\n    });\n  }\n}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\n"})})]})}s(25675);var r=!0;n.default=(0,o.j)({MDXContent:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?(0,l.jsx)(n,(0,i.Z)((0,t.Z)({},e),{children:(0,l.jsx)(c,(0,t.Z)({},e))})):c(e)},pageOpts:{filePath:"pages/en/docs/guides/event-loop-timers-and-nexttick.md",route:"",frontMatter:{title:"The Node.js Event Loop, Timers, and process.nextTick()",layout:"docs.hbs"},title:"The Node.js Event Loop, Timers, and process.nextTick()"},pageNextRoute:"/en/docs/guides/event-loop-timers-and-nexttick"})}},function(e){e.O(0,[48863,49774,92888,40179],function(){return e(e.s=59372)}),_N_E=e.O()}]);